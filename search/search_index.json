{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Django Messages DRF is an alternative and based on pinax-messages but using Django Rest Framework by making it easier to integrate with your existing project. A special thanks to pinax for inspiring me to do this and use some ideas. Overview \u00b6 django-messages-drf is an app for providing private user-to-user threaded messaging. Requirements \u00b6 Python 3.7+ Supported Django and Python Versions \u00b6 Django / Python 3.6 3.7 3.8 3.9 3.10 2.2 Yes Yes Yes Yes Yes 3.0 Yes Yes Yes Yes Yes 3.1 Yes Yes Yes Yes Yes 3.2 Yes Yes Yes Yes Yes 4.0 Yes Yes Yes Yes Yes","title":"Introduction"},{"location":"#introduction","text":"Django Messages DRF is an alternative and based on pinax-messages but using Django Rest Framework by making it easier to integrate with your existing project. A special thanks to pinax for inspiring me to do this and use some ideas.","title":"Introduction"},{"location":"#overview","text":"django-messages-drf is an app for providing private user-to-user threaded messaging.","title":"Overview"},{"location":"#requirements","text":"Python 3.7+","title":"Requirements"},{"location":"#supported-django-and-python-versions","text":"Django / Python 3.6 3.7 3.8 3.9 3.10 2.2 Yes Yes Yes Yes Yes 3.0 Yes Yes Yes Yes Yes 3.1 Yes Yes Yes Yes Yes 3.2 Yes Yes Yes Yes Yes 4.0 Yes Yes Yes Yes Yes","title":"Supported Django and Python Versions"},{"location":"installation/","text":"Installation \u00b6 $ pip install django-messages-drf Add django_messages_drf to your INSTALLED_APPS : INSTALLED_APPS = [ ... \"django_messages_drf\" , ... ] Run Django migrations to create django-messages-drf database tables: $ python manage.py migrate You'll also want to add `django_messages_drf.urls into your main urlpatterns. urlpatterns = [ # other urls path ( r \"^messages-drf/\" , include ( \"django_messages_drf.urls\" , namespace = \"django_messages_drf\" )), ]","title":"Installation"},{"location":"installation/#installation","text":"$ pip install django-messages-drf Add django_messages_drf to your INSTALLED_APPS : INSTALLED_APPS = [ ... \"django_messages_drf\" , ... ] Run Django migrations to create django-messages-drf database tables: $ python manage.py migrate You'll also want to add `django_messages_drf.urls into your main urlpatterns. urlpatterns = [ # other urls path ( r \"^messages-drf/\" , include ( \"django_messages_drf.urls\" , namespace = \"django_messages_drf\" )), ]","title":"Installation"},{"location":"mixins/","text":"Mixins \u00b6 Mixins are a super useful tool when it comes to apply the DRY principles or share functionalities across the platform. RequireUserContextView ThreadMixin CurrentThreadDefault RequireUserContextView \u00b6 A simplification of a get_serializer_context that can be applied on every serializer that needs the user in the context . class RequireUserContextView ( GenericAPIView ): \"\"\" Handles with Generics of views \"\"\" def get_serializer ( self , * args , ** kwargs ): \"\"\" Return the serializer instance that should be used for validating and deserializing input, and for serializing output. \"\"\" serializer_class = self . get_serializer_class () kwargs [ 'context' ] = self . get_serializer_context () return serializer_class ( * args , ** kwargs ) def get_serializer_context ( self ): context = super () . get_serializer_context () context . update ({ 'request' : self . request , 'user' : self . request . user , }) return context ThreadMixin \u00b6 All things common to a thread. class ThreadMixin : \"\"\" Everything related with a thread, is placed here. \"\"\" def get_thread ( self ): \"\"\"Gets the thread\"\"\" try : return Thread . objects . get ( uuid = self . kwargs . get ( 'uuid' )) except Thread . DoesNotExist : return def get_user ( self ): \"\"\"Gets a User to whom which the message will be sent\"\"\" try : return get_user_model () . objects . get ( pk = self . kwargs . get ( 'user_id' )) except get_user_model () . DoesNotExist : return def get_thead_by_id ( self ): \"\"\"Gets a thread by id\"\"\" try : return Thread . objects . get ( id = self . kwargs . get ( 'thread_id' )) except Thread . DoesNotExist : return CurrentThreadDefault \u00b6 Similar to CurrentThreadDefault , this mixin allows a similar behaviour to be injected into the serializer fields as long as the thread is passed into the context. class CurrentThreadDefault : requires_context = True def __call__ ( self , serializer_field ): return serializer_field . context [ 'thread' ] def __repr__ ( self ): return ' %s ()' % self . __class__ . __name__ Examples \u00b6 # serializers.py from django_messages.drf.mixins import CurrentThreadDefault class MessageSerializer ( serializers . ModelSerializer ): uuid = serializers . UUIDField ( required = True ) subject = serializers . CharField ( required = True ) content = serializers . CharField ( required = True , allow_null = False , allow_blank = False , error_messages = { 'blank' : _ ( \"The message cannot be empty\" ), } ) sender = serializers . HiddenField ( default = serializers . CurrentUserDefault ()) thread = serializers . HiddenField ( default = CurrentThreadDefault ())","title":"Mixins"},{"location":"mixins/#mixins","text":"Mixins are a super useful tool when it comes to apply the DRY principles or share functionalities across the platform. RequireUserContextView ThreadMixin CurrentThreadDefault","title":"Mixins"},{"location":"mixins/#requireusercontextview","text":"A simplification of a get_serializer_context that can be applied on every serializer that needs the user in the context . class RequireUserContextView ( GenericAPIView ): \"\"\" Handles with Generics of views \"\"\" def get_serializer ( self , * args , ** kwargs ): \"\"\" Return the serializer instance that should be used for validating and deserializing input, and for serializing output. \"\"\" serializer_class = self . get_serializer_class () kwargs [ 'context' ] = self . get_serializer_context () return serializer_class ( * args , ** kwargs ) def get_serializer_context ( self ): context = super () . get_serializer_context () context . update ({ 'request' : self . request , 'user' : self . request . user , }) return context","title":"RequireUserContextView"},{"location":"mixins/#threadmixin","text":"All things common to a thread. class ThreadMixin : \"\"\" Everything related with a thread, is placed here. \"\"\" def get_thread ( self ): \"\"\"Gets the thread\"\"\" try : return Thread . objects . get ( uuid = self . kwargs . get ( 'uuid' )) except Thread . DoesNotExist : return def get_user ( self ): \"\"\"Gets a User to whom which the message will be sent\"\"\" try : return get_user_model () . objects . get ( pk = self . kwargs . get ( 'user_id' )) except get_user_model () . DoesNotExist : return def get_thead_by_id ( self ): \"\"\"Gets a thread by id\"\"\" try : return Thread . objects . get ( id = self . kwargs . get ( 'thread_id' )) except Thread . DoesNotExist : return","title":"ThreadMixin"},{"location":"mixins/#currentthreaddefault","text":"Similar to CurrentThreadDefault , this mixin allows a similar behaviour to be injected into the serializer fields as long as the thread is passed into the context. class CurrentThreadDefault : requires_context = True def __call__ ( self , serializer_field ): return serializer_field . context [ 'thread' ] def __repr__ ( self ): return ' %s ()' % self . __class__ . __name__","title":"CurrentThreadDefault"},{"location":"mixins/#examples","text":"# serializers.py from django_messages.drf.mixins import CurrentThreadDefault class MessageSerializer ( serializers . ModelSerializer ): uuid = serializers . UUIDField ( required = True ) subject = serializers . CharField ( required = True ) content = serializers . CharField ( required = True , allow_null = False , allow_blank = False , error_messages = { 'blank' : _ ( \"The message cannot be empty\" ), } ) sender = serializers . HiddenField ( default = serializers . CurrentUserDefault ()) thread = serializers . HiddenField ( default = CurrentThreadDefault ())","title":"Examples"},{"location":"models/","text":"Models \u00b6 We decided to use UUIDs to make harder to make associations by using it but not using as primary key. List of Models \u00b6 Thread UserThread Message Thread \u00b6 class Thread ( AuditModel ): \"\"\"Main model where a thread is created. This model only contains a subject and a ManyToMany relationship with the users. Django by default creates an 'invisible' model when ManyToMany is declared but we can override the default and point to our own model. A `uuid` field is declared as a way to \"\"\" uuid = models . UUIDField ( blank = False , null = False , editable = False , default = uuid4 ) subject = models . CharField ( max_length = 150 ) users = models . ManyToManyField ( settings . AUTH_USER_MODEL , through = \"UserThread\" ) Thread is the main model and some sort of source of truth. Functions \u00b6 @classmethod def inbox ( cls , user ): \"\"\"Returns the inbox of a given user\"\"\" return cls . objects . filter ( userthread__user = user , userthread__deleted = False ) @classmethod def deleted ( cls , user ): \"\"\"Returns the deleted messages of a given user\"\"\" return cls . objects . filter ( userthread__user = user , userthread__deleted = True ) @classmethod def unread ( cls , user ): \"\"\"Returns all the unread messages of a given user\"\"\" return cls . objects . filter ( userthread__user = user , userthread__deleted = False , userthread__unread = True ) @property def first_message ( self ): \"\"\"Returns the first message\"\"\" return self . messages . all ()[ 0 ] @property def latest_message ( self ): \"\"\"Returs the last message\"\"\" return self . messages . order_by ( \"-sent_at\" )[ 0 ] @classmethod def ordered ( cls , objs ): \"\"\" Returns the iterable ordered the correct way, this is a class method because we don\"t know what the type of the iterable will be. \"\"\" objs = list ( objs ) objs . sort ( key = lambda o : o . latest_message . sent_at , reverse = True ) return objs @classmethod def get_thread_users ( cls ): \"\"\"Returns all the users from the thread\"\"\" return cls . users . all () def earliest_message ( self , user_to_exclude = None ): \"\"\" Returns the earliest message of the thread :param user_to_exclude: Returns a list of the messages excluding a given user. This is particulary useful for showing the earliest message sent in a thread between two different users \"\"\" try : return self . messages . exclude ( sender = user_to_exclude ) . earliest ( 'sent_at' ) except Message . DoesNotExist : return def last_message ( self ): \"\"\" Returns the latest message of the thread. Is the reverse of the `earliest_message` \"\"\" try : return self . messages . all () . latest ( 'sent_at' ) except Message . DoesNotExist : return def last_message_excluding_user ( self , user_to_exclude = None ): \"\"\" Returns the latest message of the thread. Is the reverse of the `earliest_message` :param user_to_exclude: Returns a list of the messages excluding a given user. This is particulary useful for showing the latest message sent in a thread between two different users. \"\"\" queryset = self . messages . all () try : if user_to_exclude : queryset = queryset . exclude ( sender = user_to_exclude ) return queryset . latest ( 'sent_at' ) except Message . DoesNotExist : return def unread_messages ( self , user ): \"\"\" Gets the unread messages from User in a given Thread. Example: ''' t = Thread.objects.first() user = User.objects.first() unread = t.uread_messages(user) ''' \"\"\" return self . userthread_set . filter ( user = user , deleted = False , unread = True , thread = self ) def is_user_first_message ( self , user ): \"\"\" Checks if the user started the thread :return: Bool \"\"\" try : message = self . messages . earliest ( 'sent_at' ) except Message . DoesNotExist : return False return bool ( message . sender . pk == user . pk ) UserThread \u00b6 class UserThread ( models . Model ): \"\"\"Maps the user and the thread. This model was used to override the default ManyToMany relationship table generated by django. \"\"\" uuid = models . UUIDField ( blank = False , null = False , default = uuid4 , editable = False ,) thread = models . ForeignKey ( Thread , on_delete = models . CASCADE ) user = models . ForeignKey ( settings . AUTH_USER_MODEL , on_delete = models . CASCADE ) unread = models . BooleanField () deleted = models . BooleanField () This model is a substitution of the default generated by ManyToMany of Django. Message \u00b6 class Message ( models . Model ): \"\"\" Message model where creates threads, user threads and mapping between them. \"\"\" uuid = models . UUIDField ( blank = False , null = False , default = uuid4 , editable = False ) thread = models . ForeignKey ( Thread , related_name = \"messages\" , on_delete = models . CASCADE ) sender = models . ForeignKey ( settings . AUTH_USER_MODEL , related_name = \"sent_messages\" , on_delete = models . CASCADE ) sent_at = models . DateTimeField ( default = timezone . now ) content = models . TextField () Functions \u00b6 @classmethod def new_reply ( cls , thread , user , content ): \"\"\" Create a new reply for an existing Thread. Mark thread as unread for all other participants, and mark thread as read by replier. We want an atomic operation as we can't afford having lost data between tables and causing problems with data integrity. \"\"\" with transaction . atomic (): try : msg = cls . objects . create ( thread = thread , sender = user , content = content ) thread . userthread_set . exclude ( user = user ) . update ( deleted = False , unread = True ) thread . userthread_set . filter ( user = user ) . update ( deleted = False , unread = False ) message_sent . send ( sender = cls , message = msg , thread = thread , reply = True ) except OperationalError as e : log . exception ( e ) return return msg @classmethod def new_message ( cls , from_user , to_users , subject , content ): \"\"\" Create a new Message and Thread. Mark thread as unread for all recipients, and mark thread as read and deleted from inbox by creator. We want an atomic operation as we also can't afford having lost data between tables and causing problems with data integrity. \"\"\" with transaction . atomic (): try : thread = Thread . objects . create ( subject = subject ) for user in to_users : thread . userthread_set . create ( user = user , deleted = False , unread = True ) thread . userthread_set . create ( user = from_user , deleted = True , unread = False ) msg = cls . objects . create ( thread = thread , sender = from_user , content = content ) message_sent . send ( sender = cls , message = msg , thread = thread , reply = False ) except OperationalError as e : log . exception ( e ) return return msg def get_absolute_url ( self ): return self . thread . get_absolute_url () Tips \u00b6 When creating a new message, the default behavior is calling the new_message or reply_message , depending of the type.","title":"Models"},{"location":"models/#models","text":"We decided to use UUIDs to make harder to make associations by using it but not using as primary key.","title":"Models"},{"location":"models/#list-of-models","text":"Thread UserThread Message","title":"List of Models"},{"location":"models/#thread","text":"class Thread ( AuditModel ): \"\"\"Main model where a thread is created. This model only contains a subject and a ManyToMany relationship with the users. Django by default creates an 'invisible' model when ManyToMany is declared but we can override the default and point to our own model. A `uuid` field is declared as a way to \"\"\" uuid = models . UUIDField ( blank = False , null = False , editable = False , default = uuid4 ) subject = models . CharField ( max_length = 150 ) users = models . ManyToManyField ( settings . AUTH_USER_MODEL , through = \"UserThread\" ) Thread is the main model and some sort of source of truth.","title":"Thread"},{"location":"models/#functions","text":"@classmethod def inbox ( cls , user ): \"\"\"Returns the inbox of a given user\"\"\" return cls . objects . filter ( userthread__user = user , userthread__deleted = False ) @classmethod def deleted ( cls , user ): \"\"\"Returns the deleted messages of a given user\"\"\" return cls . objects . filter ( userthread__user = user , userthread__deleted = True ) @classmethod def unread ( cls , user ): \"\"\"Returns all the unread messages of a given user\"\"\" return cls . objects . filter ( userthread__user = user , userthread__deleted = False , userthread__unread = True ) @property def first_message ( self ): \"\"\"Returns the first message\"\"\" return self . messages . all ()[ 0 ] @property def latest_message ( self ): \"\"\"Returs the last message\"\"\" return self . messages . order_by ( \"-sent_at\" )[ 0 ] @classmethod def ordered ( cls , objs ): \"\"\" Returns the iterable ordered the correct way, this is a class method because we don\"t know what the type of the iterable will be. \"\"\" objs = list ( objs ) objs . sort ( key = lambda o : o . latest_message . sent_at , reverse = True ) return objs @classmethod def get_thread_users ( cls ): \"\"\"Returns all the users from the thread\"\"\" return cls . users . all () def earliest_message ( self , user_to_exclude = None ): \"\"\" Returns the earliest message of the thread :param user_to_exclude: Returns a list of the messages excluding a given user. This is particulary useful for showing the earliest message sent in a thread between two different users \"\"\" try : return self . messages . exclude ( sender = user_to_exclude ) . earliest ( 'sent_at' ) except Message . DoesNotExist : return def last_message ( self ): \"\"\" Returns the latest message of the thread. Is the reverse of the `earliest_message` \"\"\" try : return self . messages . all () . latest ( 'sent_at' ) except Message . DoesNotExist : return def last_message_excluding_user ( self , user_to_exclude = None ): \"\"\" Returns the latest message of the thread. Is the reverse of the `earliest_message` :param user_to_exclude: Returns a list of the messages excluding a given user. This is particulary useful for showing the latest message sent in a thread between two different users. \"\"\" queryset = self . messages . all () try : if user_to_exclude : queryset = queryset . exclude ( sender = user_to_exclude ) return queryset . latest ( 'sent_at' ) except Message . DoesNotExist : return def unread_messages ( self , user ): \"\"\" Gets the unread messages from User in a given Thread. Example: ''' t = Thread.objects.first() user = User.objects.first() unread = t.uread_messages(user) ''' \"\"\" return self . userthread_set . filter ( user = user , deleted = False , unread = True , thread = self ) def is_user_first_message ( self , user ): \"\"\" Checks if the user started the thread :return: Bool \"\"\" try : message = self . messages . earliest ( 'sent_at' ) except Message . DoesNotExist : return False return bool ( message . sender . pk == user . pk )","title":"Functions"},{"location":"models/#userthread","text":"class UserThread ( models . Model ): \"\"\"Maps the user and the thread. This model was used to override the default ManyToMany relationship table generated by django. \"\"\" uuid = models . UUIDField ( blank = False , null = False , default = uuid4 , editable = False ,) thread = models . ForeignKey ( Thread , on_delete = models . CASCADE ) user = models . ForeignKey ( settings . AUTH_USER_MODEL , on_delete = models . CASCADE ) unread = models . BooleanField () deleted = models . BooleanField () This model is a substitution of the default generated by ManyToMany of Django.","title":"UserThread"},{"location":"models/#message","text":"class Message ( models . Model ): \"\"\" Message model where creates threads, user threads and mapping between them. \"\"\" uuid = models . UUIDField ( blank = False , null = False , default = uuid4 , editable = False ) thread = models . ForeignKey ( Thread , related_name = \"messages\" , on_delete = models . CASCADE ) sender = models . ForeignKey ( settings . AUTH_USER_MODEL , related_name = \"sent_messages\" , on_delete = models . CASCADE ) sent_at = models . DateTimeField ( default = timezone . now ) content = models . TextField ()","title":"Message"},{"location":"models/#functions_1","text":"@classmethod def new_reply ( cls , thread , user , content ): \"\"\" Create a new reply for an existing Thread. Mark thread as unread for all other participants, and mark thread as read by replier. We want an atomic operation as we can't afford having lost data between tables and causing problems with data integrity. \"\"\" with transaction . atomic (): try : msg = cls . objects . create ( thread = thread , sender = user , content = content ) thread . userthread_set . exclude ( user = user ) . update ( deleted = False , unread = True ) thread . userthread_set . filter ( user = user ) . update ( deleted = False , unread = False ) message_sent . send ( sender = cls , message = msg , thread = thread , reply = True ) except OperationalError as e : log . exception ( e ) return return msg @classmethod def new_message ( cls , from_user , to_users , subject , content ): \"\"\" Create a new Message and Thread. Mark thread as unread for all recipients, and mark thread as read and deleted from inbox by creator. We want an atomic operation as we also can't afford having lost data between tables and causing problems with data integrity. \"\"\" with transaction . atomic (): try : thread = Thread . objects . create ( subject = subject ) for user in to_users : thread . userthread_set . create ( user = user , deleted = False , unread = True ) thread . userthread_set . create ( user = from_user , deleted = True , unread = False ) msg = cls . objects . create ( thread = thread , sender = from_user , content = content ) message_sent . send ( sender = cls , message = msg , thread = thread , reply = False ) except OperationalError as e : log . exception ( e ) return return msg def get_absolute_url ( self ): return self . thread . get_absolute_url ()","title":"Functions"},{"location":"models/#tips","text":"When creating a new message, the default behavior is calling the new_message or reply_message , depending of the type.","title":"Tips"},{"location":"pagination/","text":"Pagination \u00b6 Two custom pagination classes are provided for the application. The information was gathered from here . Pagination SimplePagination Pagination \u00b6 class Pagination ( pagination . PageNumberPagination ): \"\"\" Custom paginator for REST API responses 'links': { 'next': next page url, 'previous': previous page url }, 'count': number of records fetched, 'total_pages': total number of pages, 'next': bool has next page, 'previous': bool has previous page, 'results': result set }) \"\"\" def get_paginated_response ( self , data ): return Response ({ 'links' : { 'next' : self . get_next_link (), 'previous' : self . get_previous_link () }, 'pagination' : { 'previous_page' : self . page . number - 1 if self . page . number != 1 else None , 'current_page' : self . page . number , 'next_page' : self . page . number + 1 if self . page . has_next () else None , 'page_size' : self . page_size }, 'count' : self . page . paginator . count , 'total_pages' : self . page . paginator . num_pages , 'next' : self . page . has_next (), 'previous' : self . page . has_previous (), 'results' : data }) SimplePagination \u00b6 class SimplePagination ( pagination . PageNumberPagination ): \"\"\" Custom paginator for REST API responses \"\"\" def get_paginated_response ( self , data ): return Response ({ 'records_filtered' : self . page . paginator . count , 'data' : data })","title":"Pagination"},{"location":"pagination/#pagination","text":"Two custom pagination classes are provided for the application. The information was gathered from here . Pagination SimplePagination","title":"Pagination"},{"location":"pagination/#pagination_1","text":"class Pagination ( pagination . PageNumberPagination ): \"\"\" Custom paginator for REST API responses 'links': { 'next': next page url, 'previous': previous page url }, 'count': number of records fetched, 'total_pages': total number of pages, 'next': bool has next page, 'previous': bool has previous page, 'results': result set }) \"\"\" def get_paginated_response ( self , data ): return Response ({ 'links' : { 'next' : self . get_next_link (), 'previous' : self . get_previous_link () }, 'pagination' : { 'previous_page' : self . page . number - 1 if self . page . number != 1 else None , 'current_page' : self . page . number , 'next_page' : self . page . number + 1 if self . page . has_next () else None , 'page_size' : self . page_size }, 'count' : self . page . paginator . count , 'total_pages' : self . page . paginator . num_pages , 'next' : self . page . has_next (), 'previous' : self . page . has_previous (), 'results' : data })","title":"Pagination"},{"location":"pagination/#simplepagination","text":"class SimplePagination ( pagination . PageNumberPagination ): \"\"\" Custom paginator for REST API responses \"\"\" def get_paginated_response ( self , data ): return Response ({ 'records_filtered' : self . page . paginator . count , 'data' : data })","title":"SimplePagination"},{"location":"permissions/","text":"Permissions \u00b6 A small set of permissions are set in the app to make sure the data is safer and secure and those can be also extended. AccessMixin DjangoMessageDRFAuthMixin AccessMixin \u00b6 Base class of all permission mixins of Django Messages DRF. Adds an extension for the permissions of Django Rest Framework where you can now append into a list instead of repeating on every class. class AccessMixin ( metaclass = DjangoMessageDRFAuthMeta ): \"\"\" Django rest framework doesn't append permission_classes on inherited models which can cause issues when it comes to call an API programmatically, this way we create a metaclass that will read from a property custom from our subclasses and will append to the default `permission_classes` on the subclasses of AccessMixin. \"\"\" pass DjangoMessageDRFAuthMixin \u00b6 Base class of all views of the application and sets the principle that every view inheriting from this will validate the user authentication. class DjangoMessageDRFAuthMixin ( AccessMixin , APIView ): \"\"\" Base APIView requiring login credentials to access it from the inside of the platform Or via request (if known) \"\"\" permissions = [ IsAuthenticated ] pagination_class = None def __init__ ( self , * args , ** kwargs ) -> None : \"\"\" Checks if the views contain the `permissions` attribute and overrides the `permission_classes`. \"\"\" super () . __init__ ( * args , ** kwargs ) self . permission_classes = self . permissions if self . pagination_class : try : rest_settings = settings . REST_FRAMEWORK except AttributeError : rest_settings = {} page_size = rest_settings . get ( 'PAGE_SIZE' , 50 ) self . pagination_class . page_size = page_size Examples \u00b6 Using the DjangoMessageDRFAuthMixin as a base we can now start creating our own views without thinking about replicating the permission_classes . With DjangoMessageDRFAuthMixin \u00b6 from rest_framework.views import APIView from django_messages_drf.permissions import DjangoMessageDRFAuthMixin from my_app.permissions import MyPermission class MyCustomView ( DjangoMessageDRFAuthMixin , APiView ): \"\"\" My Custom view that will do things \"\"\" permissions = [ MyPermission ] Importing the APIView is optional since the DjangoMessageDRFAuthMixin already implements it. Behind the scenes, Django Messages DRF is appending the permissions to permission_classes of Django Rest Framework, which means that if we query for the permission_classes we would have: permission_classes = [ IsAuthenticated, MyPermission ] Without DjangoMessageDRFAuthMixin \u00b6 from rest_framework.views import APIView from rest_framework.permissions import IsAuthenticated from my_app.permissions import MyPermission class BaseView ( APiView ): permission_classes = [ IsAuthenticated ] class MyCustomView ( BaseView ): \"\"\" My Custom view that will do things \"\"\" permission_classes = [ MyPermission ] This won't have the same result as the DjangoMessageDRFAuthMixin because what is doing is actually reassigning the permission_classes from the BaseView to the MyCustomView .","title":"Permissions"},{"location":"permissions/#permissions","text":"A small set of permissions are set in the app to make sure the data is safer and secure and those can be also extended. AccessMixin DjangoMessageDRFAuthMixin","title":"Permissions"},{"location":"permissions/#accessmixin","text":"Base class of all permission mixins of Django Messages DRF. Adds an extension for the permissions of Django Rest Framework where you can now append into a list instead of repeating on every class. class AccessMixin ( metaclass = DjangoMessageDRFAuthMeta ): \"\"\" Django rest framework doesn't append permission_classes on inherited models which can cause issues when it comes to call an API programmatically, this way we create a metaclass that will read from a property custom from our subclasses and will append to the default `permission_classes` on the subclasses of AccessMixin. \"\"\" pass","title":"AccessMixin"},{"location":"permissions/#djangomessagedrfauthmixin","text":"Base class of all views of the application and sets the principle that every view inheriting from this will validate the user authentication. class DjangoMessageDRFAuthMixin ( AccessMixin , APIView ): \"\"\" Base APIView requiring login credentials to access it from the inside of the platform Or via request (if known) \"\"\" permissions = [ IsAuthenticated ] pagination_class = None def __init__ ( self , * args , ** kwargs ) -> None : \"\"\" Checks if the views contain the `permissions` attribute and overrides the `permission_classes`. \"\"\" super () . __init__ ( * args , ** kwargs ) self . permission_classes = self . permissions if self . pagination_class : try : rest_settings = settings . REST_FRAMEWORK except AttributeError : rest_settings = {} page_size = rest_settings . get ( 'PAGE_SIZE' , 50 ) self . pagination_class . page_size = page_size","title":"DjangoMessageDRFAuthMixin"},{"location":"permissions/#examples","text":"Using the DjangoMessageDRFAuthMixin as a base we can now start creating our own views without thinking about replicating the permission_classes .","title":"Examples"},{"location":"permissions/#with-djangomessagedrfauthmixin","text":"from rest_framework.views import APIView from django_messages_drf.permissions import DjangoMessageDRFAuthMixin from my_app.permissions import MyPermission class MyCustomView ( DjangoMessageDRFAuthMixin , APiView ): \"\"\" My Custom view that will do things \"\"\" permissions = [ MyPermission ] Importing the APIView is optional since the DjangoMessageDRFAuthMixin already implements it. Behind the scenes, Django Messages DRF is appending the permissions to permission_classes of Django Rest Framework, which means that if we query for the permission_classes we would have: permission_classes = [ IsAuthenticated, MyPermission ]","title":"With DjangoMessageDRFAuthMixin"},{"location":"permissions/#without-djangomessagedrfauthmixin","text":"from rest_framework.views import APIView from rest_framework.permissions import IsAuthenticated from my_app.permissions import MyPermission class BaseView ( APiView ): permission_classes = [ IsAuthenticated ] class MyCustomView ( BaseView ): \"\"\" My Custom view that will do things \"\"\" permission_classes = [ MyPermission ] This won't have the same result as the DjangoMessageDRFAuthMixin because what is doing is actually reassigning the permission_classes from the BaseView to the MyCustomView .","title":"Without DjangoMessageDRFAuthMixin"},{"location":"release-notes/","text":"Release Notes \u00b6 1.0.6 \u00b6 Preparing to drop support for python 3.6. Fix providing_args from signals as it is deprecated in Django 4. 1.0.5 \u00b6 Added id field to the ThreadSerializer. 1.0.4 \u00b6 Bugfix #10 . Thank you kamikaz1k Bugfix #9 . Thank you kamikaz1k 1.0.3 \u00b6 Added \u00b6 Settings to override the serializers on the views by using a custom. EditMessageApiView allowing editing a message sent from a user of a given thread. CurrentThreadDefault similar to CurrentUserDefault from Django Rest Framework but for threads. Fixed \u00b6 Show sender when a message sent is from the same sender and receiver - Issue Issue with display_name for InboxSerializer - Issue . ThreadCRUDApiView post where wasn't using the data from the serializer. 1.0.2 \u00b6 Added \u00b6 Support for python 3.9 CircleCI config Fixed \u00b6 Tests naming conflicts. Migration issues. Updated \u00b6 README. 1.0.0 \u00b6 Initial release License \u00b6 Copyright (c) 2020-present Tiago Silva and contributors under the MIT license .","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#106","text":"Preparing to drop support for python 3.6. Fix providing_args from signals as it is deprecated in Django 4.","title":"1.0.6"},{"location":"release-notes/#105","text":"Added id field to the ThreadSerializer.","title":"1.0.5"},{"location":"release-notes/#104","text":"Bugfix #10 . Thank you kamikaz1k Bugfix #9 . Thank you kamikaz1k","title":"1.0.4"},{"location":"release-notes/#103","text":"","title":"1.0.3"},{"location":"release-notes/#added","text":"Settings to override the serializers on the views by using a custom. EditMessageApiView allowing editing a message sent from a user of a given thread. CurrentThreadDefault similar to CurrentUserDefault from Django Rest Framework but for threads.","title":"Added"},{"location":"release-notes/#fixed","text":"Show sender when a message sent is from the same sender and receiver - Issue Issue with display_name for InboxSerializer - Issue . ThreadCRUDApiView post where wasn't using the data from the serializer.","title":"Fixed"},{"location":"release-notes/#102","text":"","title":"1.0.2"},{"location":"release-notes/#added_1","text":"Support for python 3.9 CircleCI config","title":"Added"},{"location":"release-notes/#fixed_1","text":"Tests naming conflicts. Migration issues.","title":"Fixed"},{"location":"release-notes/#updated","text":"README.","title":"Updated"},{"location":"release-notes/#100","text":"Initial release","title":"1.0.0"},{"location":"release-notes/#license","text":"Copyright (c) 2020-present Tiago Silva and contributors under the MIT license .","title":"License"},{"location":"serializers/","text":"Serializers \u00b6 Django Messages DRF like with the views, also comes with a set of serializers that allows you to apply in your project but you can and should build your own with your own use cases. The way the serializers are built are the default ones from Django Rest Framework. Examples \u00b6 Inbox \u00b6 A simple example for an inbox serializer. class InboxSerializer ( serializers . ModelSerializer ): \"\"\" Serializer for the inbox. \"\"\" sent_at = serializers . DateTimeField ( source = 'first_message.sent_at' ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . useruser = self . context . get ( 'user' ) class Meta : model = Thread fields = ( 'uuid' , 'subject' , 'sent_at' ) Sender \u00b6 A sender for Django Messages DRF is a Django user and can be whatever you decided that u. class SenderSerializer ( serializers . ModelSerializer ): class Meta : model = get_user_model () fields = ( 'first_name' , 'last_name' , 'email' )","title":"Serializers"},{"location":"serializers/#serializers","text":"Django Messages DRF like with the views, also comes with a set of serializers that allows you to apply in your project but you can and should build your own with your own use cases. The way the serializers are built are the default ones from Django Rest Framework.","title":"Serializers"},{"location":"serializers/#examples","text":"","title":"Examples"},{"location":"serializers/#inbox","text":"A simple example for an inbox serializer. class InboxSerializer ( serializers . ModelSerializer ): \"\"\" Serializer for the inbox. \"\"\" sent_at = serializers . DateTimeField ( source = 'first_message.sent_at' ) def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . useruser = self . context . get ( 'user' ) class Meta : model = Thread fields = ( 'uuid' , 'subject' , 'sent_at' )","title":"Inbox"},{"location":"serializers/#sender","text":"A sender for Django Messages DRF is a Django user and can be whatever you decided that u. class SenderSerializer ( serializers . ModelSerializer ): class Meta : model = get_user_model () fields = ( 'first_name' , 'last_name' , 'email' )","title":"Sender"},{"location":"settings/","text":"Serializer Settings \u00b6 Django Messages DRF allows overriding some settings for the views, which means, instead of creating a new view just to apply your own serializer, you can simply override the setting and Django Messages DRF will apply it on the current views. None of the below settings are required to be added to your settings.py . This is only if you wish to override the current defaults. Overriding \u00b6 In your settings.py . Setting Name View Default DJANGO_MESSAGES_DRF_INBOX_SERIALIZER InboxListApiView InboxSerializer DJANGO_MESSAGES_DRF_THREAD_SERIALIZER ThreadListApiView ThreadSerializer DJANGO_MESSAGES_DRF_MESSAGE_SERIALIZER ThreadCRUDApiView ThreadReplySerializer DJANGO_MESSAGES_DRF_EDIT_MESSAGE_SERIALIZER EditMessageApiView EditMessageSerializer Usage \u00b6 Overriding is based on import_string from your settings.py . Examples \u00b6 # settings.py DJANGO_MESSAGES_DRF_INBOX_SERIALIZER = 'myapp.serializers.MyCustomInboxSerializer' DJANGO_MESSAGES_DRF_THREAD_SERIALIZER = 'myapp.serializers.MyCustomThreadSerializer' If none of the settings is overridden or is None , then it will default to the original. Behaviour Settings \u00b6 Django Messages DRF allows overriding some behaviours. Overriding \u00b6 In your settings.py . Setting Name Behaviour Type Default DJANGO_MESSAGES_MARK_NEW_THREAD_MESSAGE_AS_DELETED Mark the first message sent as deleted Boolean True","title":"Settings"},{"location":"settings/#serializer-settings","text":"Django Messages DRF allows overriding some settings for the views, which means, instead of creating a new view just to apply your own serializer, you can simply override the setting and Django Messages DRF will apply it on the current views. None of the below settings are required to be added to your settings.py . This is only if you wish to override the current defaults.","title":"Serializer Settings"},{"location":"settings/#overriding","text":"In your settings.py . Setting Name View Default DJANGO_MESSAGES_DRF_INBOX_SERIALIZER InboxListApiView InboxSerializer DJANGO_MESSAGES_DRF_THREAD_SERIALIZER ThreadListApiView ThreadSerializer DJANGO_MESSAGES_DRF_MESSAGE_SERIALIZER ThreadCRUDApiView ThreadReplySerializer DJANGO_MESSAGES_DRF_EDIT_MESSAGE_SERIALIZER EditMessageApiView EditMessageSerializer","title":"Overriding"},{"location":"settings/#usage","text":"Overriding is based on import_string from your settings.py .","title":"Usage"},{"location":"settings/#examples","text":"# settings.py DJANGO_MESSAGES_DRF_INBOX_SERIALIZER = 'myapp.serializers.MyCustomInboxSerializer' DJANGO_MESSAGES_DRF_THREAD_SERIALIZER = 'myapp.serializers.MyCustomThreadSerializer' If none of the settings is overridden or is None , then it will default to the original.","title":"Examples"},{"location":"settings/#behaviour-settings","text":"Django Messages DRF allows overriding some behaviours.","title":"Behaviour Settings"},{"location":"settings/#overriding_1","text":"In your settings.py . Setting Name Behaviour Type Default DJANGO_MESSAGES_MARK_NEW_THREAD_MESSAGE_AS_DELETED Mark the first message sent as deleted Boolean True","title":"Overriding"},{"location":"utils/","text":"Utils \u00b6 Some useful utils are provided with the project to make it easier to reuse across. AuditModel AuditModel \u00b6 class AuditModel ( models . Model ): \"\"\"A common audit model for tracking\"\"\" created_at = models . DateTimeField ( null = False , blank = False , auto_now_add = True ) modified_at = models . DateTimeField ( null = False , blank = False , auto_now = True ) Adding the AuditModel to a model will add an audit trailing to it making it easier to filter by dates. This can be extended and add more information such as created_by or modified_by where those are users of the application.","title":"Utils"},{"location":"utils/#utils","text":"Some useful utils are provided with the project to make it easier to reuse across. AuditModel","title":"Utils"},{"location":"utils/#auditmodel","text":"class AuditModel ( models . Model ): \"\"\"A common audit model for tracking\"\"\" created_at = models . DateTimeField ( null = False , blank = False , auto_now_add = True ) modified_at = models . DateTimeField ( null = False , blank = False , auto_now = True ) Adding the AuditModel to a model will add an audit trailing to it making it easier to filter by dates. This can be extended and add more information such as created_by or modified_by where those are users of the application.","title":"AuditModel"},{"location":"views/","text":"Views \u00b6 Django Messages DRF comes initially with a set of views that allows you to apply in your projects. All the views are in Django Rest Framework and allowing customization up to a certain level. All of the serializers are provided by the settings and allows overriding from there. List of Views \u00b6 InboxListApiView ThreadListApiView ThreadCRUDApiView EditMessageApiView InboxListApiView \u00b6 The main view for an inbox of a user where return an ordered list from the latest received to the first. class InboxListApiView ( DjangoMessageDRFAuthMixin , RequireUserContextView , ListAPIView ): \"\"\" Returns the Inbox the logged in User \"\"\" serializer_class = InboxSerializer pagination_class = Pagination def get_queryset ( self ): queryset = Thread . inbox ( self . request . user ) return Thread . ordered ( queryset ) Tips \u00b6 We use a custom Pagination object that adds some more details to the default Django Pagination. You can have your own pagination object and override the default. # Custom Pagination Applied to the view from rest_framework import pagination from django_messages_drf.views import InboxListApiView class MyCustomPagination ( pagination . PageNumberPagination ): # Add custom pagination logic class MyInboxListApiView ( InboxListApiView ): pagination_class = MyCustomPagination You can also override the serializer_class default using the same principle. # Custom Pagination Applied to the view from rest_framework import serializers from django_messages_drf.views import InboxListApiView class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyInboxListApiView ( InboxListApiView ): serializer_class = MyCustomSerializer Or combining both pagination and serializer_class in one. # Custom Pagination Applied to the view from rest_framework import pagination from rest_framework import serializers from django_messages_drf.views import InboxListApiView class MyCustomPagination ( pagination . PageNumberPagination ): # Add custom pagination logic class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyInboxListApiView ( InboxListApiView ): serializer_class = MyCustomSerializer pagination_class = MyCustomPagination ThreadListApiView \u00b6 class ThreadListApiView ( DjangoMessageDRFAuthMixin , ThreadMixin , RequireUserContextView , ListAPIView ): \"\"\" Gets all the messages from a given thread \"\"\" serializer_class = ThreadSerializer def get ( self , request , * args , ** kwargs ): instance = self . get_thread () if not instance : raise NotFound ( code = status . HTTP_404_NOT_FOUND ) serializer = self . serializer_class ( instance , context = self . get_serializer_context ()) return Response ( serializer . data , status = status . HTTP_200_OK ) Tips \u00b6 The same logic for ThreadListApiView is the same applied for InboxListApiView by overriding the default serializer_class . # Custom Pagination Applied to the view from rest_framework import serializers from django_messages_drf.views import ThreadListApiView class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyThreadListApiView ( ThreadListApiView ): serializer_class = MyCustomSerializer ThreadCRUDApiView \u00b6 class ThreadCRUDApiView ( DjangoMessageDRFAuthMixin , ThreadMixin , RequireUserContextView , APIView ): \"\"\" View that allows the reply of a specific message as well as the We will apply some pagination to return a list for the results and therefore 1. This API gets or creates the Thread 2. If a UUID is passed, then a Thread is validated and created but if only a user_id is passed, then it will create a new thread and start a conversation. \"\"\" serializer_class = ThreadReplySerializer def post ( self , request , uuid = None , * args , ** kwargs ): \"\"\" Replies a mensage in given thread \"\"\" thread = self . get_thread () if uuid else None user = self . get_user () if not user : raise NotFound ( code = status . HTTP_404_NOT_FOUND ) serializer = self . serializer_class ( data = request . data ) serializer . is_valid ( raise_exception = True ) subject = request . data . get ( 'subject' ) or thread . subject if not thread : msg = Message . new_message ( from_user = self . request . user , to_users = [ user ], subject = subject , content = request . data . get ( 'message' ) ) else : msg = Message . new_reply ( thread , self . request . user , request . data . get ( 'message' )) thread . subject = subject thread . save () message = MessageSerializer ( msg , context = self . get_serializer_context ()) return Response ( message . data , status = status . HTTP_200_OK ) def delete ( self , request , * args , ** kwargs ): \"\"\" Flags a thread as deleted a thread from the system. To remove completely, another permanent view can be added to execute the action. \"\"\" thread = self . get_thread () if not thread : raise NotFound ( code = status . HTTP_404_NOT_FOUND ) thread . userthread_set . filter ( user = request . user ) . update ( deleted = True ) return Response ( status = status . HTTP_200_OK ) Tips \u00b6 The same logic for ThreadCRUDApiView is the same applied for InboxListApiView by overriding the default serializer_class . # Custom Pagination Applied to the view from rest_framework import serializers from django_messages_drf.views import ThreadCRUDApiView class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyThreadCRUDApiView ( ThreadCRUDApiView ): serializer_class = MyCustomSerializer EditMessageApiView \u00b6 class EditMessageApiView ( DjangoMessageDRFAuthMixin , ThreadMixin , RequireUserContextView , APIView ): \"\"\" Edits a message sent from a user in a given thread \"\"\" serializer_class = EDIT_MESSAGE_SERIALIZER def get_instance ( self , user , message_uuid ): \"\"\" Checks of the message exists \"\"\" try : return Message . objects . get ( sender = user , uuid = message_uuid ) except Message . DoesNotExist : return def get_serializer_context ( self ): context = super () . get_serializer_context () context . update ({ 'thread' : self . get_thead_by_id (), }) return context def put ( self , request , user_id , thread_id , * args , ** kwargs ): \"\"\" Edits a mensage in given thread. 1. Gets the user_id from the URL. 2. From the request.data gets the uuid of the message 3. Validates 4. Saves and returns \"\"\" user = self . get_user () if not user : raise NotFound () if ( not user . pk == request . user . pk ): raise PermissionDenied () # Get the instance of the message for a given user instance = self . get_instance ( user , request . data . get ( 'uuid' )) if not instance : raise NotFound () serializer = self . serializer_class ( instance , data = request . data , context = self . get_serializer_context ()) serializer . is_valid ( raise_exception = True ) instance = serializer . save () message = MessageSerializer ( instance , context = self . get_serializer_context ()) return Response ( message . data , status = status . HTTP_200_OK ) General Tip \u00b6 The views follow a similar structure and design everywhere but they can also be overwritten in a normal Django way. Checkout the settings page to see how to override the variables.","title":"Views"},{"location":"views/#views","text":"Django Messages DRF comes initially with a set of views that allows you to apply in your projects. All the views are in Django Rest Framework and allowing customization up to a certain level. All of the serializers are provided by the settings and allows overriding from there.","title":"Views"},{"location":"views/#list-of-views","text":"InboxListApiView ThreadListApiView ThreadCRUDApiView EditMessageApiView","title":"List of Views"},{"location":"views/#inboxlistapiview","text":"The main view for an inbox of a user where return an ordered list from the latest received to the first. class InboxListApiView ( DjangoMessageDRFAuthMixin , RequireUserContextView , ListAPIView ): \"\"\" Returns the Inbox the logged in User \"\"\" serializer_class = InboxSerializer pagination_class = Pagination def get_queryset ( self ): queryset = Thread . inbox ( self . request . user ) return Thread . ordered ( queryset )","title":"InboxListApiView"},{"location":"views/#tips","text":"We use a custom Pagination object that adds some more details to the default Django Pagination. You can have your own pagination object and override the default. # Custom Pagination Applied to the view from rest_framework import pagination from django_messages_drf.views import InboxListApiView class MyCustomPagination ( pagination . PageNumberPagination ): # Add custom pagination logic class MyInboxListApiView ( InboxListApiView ): pagination_class = MyCustomPagination You can also override the serializer_class default using the same principle. # Custom Pagination Applied to the view from rest_framework import serializers from django_messages_drf.views import InboxListApiView class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyInboxListApiView ( InboxListApiView ): serializer_class = MyCustomSerializer Or combining both pagination and serializer_class in one. # Custom Pagination Applied to the view from rest_framework import pagination from rest_framework import serializers from django_messages_drf.views import InboxListApiView class MyCustomPagination ( pagination . PageNumberPagination ): # Add custom pagination logic class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyInboxListApiView ( InboxListApiView ): serializer_class = MyCustomSerializer pagination_class = MyCustomPagination","title":"Tips"},{"location":"views/#threadlistapiview","text":"class ThreadListApiView ( DjangoMessageDRFAuthMixin , ThreadMixin , RequireUserContextView , ListAPIView ): \"\"\" Gets all the messages from a given thread \"\"\" serializer_class = ThreadSerializer def get ( self , request , * args , ** kwargs ): instance = self . get_thread () if not instance : raise NotFound ( code = status . HTTP_404_NOT_FOUND ) serializer = self . serializer_class ( instance , context = self . get_serializer_context ()) return Response ( serializer . data , status = status . HTTP_200_OK )","title":"ThreadListApiView"},{"location":"views/#tips_1","text":"The same logic for ThreadListApiView is the same applied for InboxListApiView by overriding the default serializer_class . # Custom Pagination Applied to the view from rest_framework import serializers from django_messages_drf.views import ThreadListApiView class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyThreadListApiView ( ThreadListApiView ): serializer_class = MyCustomSerializer","title":"Tips"},{"location":"views/#threadcrudapiview","text":"class ThreadCRUDApiView ( DjangoMessageDRFAuthMixin , ThreadMixin , RequireUserContextView , APIView ): \"\"\" View that allows the reply of a specific message as well as the We will apply some pagination to return a list for the results and therefore 1. This API gets or creates the Thread 2. If a UUID is passed, then a Thread is validated and created but if only a user_id is passed, then it will create a new thread and start a conversation. \"\"\" serializer_class = ThreadReplySerializer def post ( self , request , uuid = None , * args , ** kwargs ): \"\"\" Replies a mensage in given thread \"\"\" thread = self . get_thread () if uuid else None user = self . get_user () if not user : raise NotFound ( code = status . HTTP_404_NOT_FOUND ) serializer = self . serializer_class ( data = request . data ) serializer . is_valid ( raise_exception = True ) subject = request . data . get ( 'subject' ) or thread . subject if not thread : msg = Message . new_message ( from_user = self . request . user , to_users = [ user ], subject = subject , content = request . data . get ( 'message' ) ) else : msg = Message . new_reply ( thread , self . request . user , request . data . get ( 'message' )) thread . subject = subject thread . save () message = MessageSerializer ( msg , context = self . get_serializer_context ()) return Response ( message . data , status = status . HTTP_200_OK ) def delete ( self , request , * args , ** kwargs ): \"\"\" Flags a thread as deleted a thread from the system. To remove completely, another permanent view can be added to execute the action. \"\"\" thread = self . get_thread () if not thread : raise NotFound ( code = status . HTTP_404_NOT_FOUND ) thread . userthread_set . filter ( user = request . user ) . update ( deleted = True ) return Response ( status = status . HTTP_200_OK )","title":"ThreadCRUDApiView"},{"location":"views/#tips_2","text":"The same logic for ThreadCRUDApiView is the same applied for InboxListApiView by overriding the default serializer_class . # Custom Pagination Applied to the view from rest_framework import serializers from django_messages_drf.views import ThreadCRUDApiView class MyCustomSerializer ( serializers . ModelSerializer ): # Add custom serializer logic class MyThreadCRUDApiView ( ThreadCRUDApiView ): serializer_class = MyCustomSerializer","title":"Tips"},{"location":"views/#editmessageapiview","text":"class EditMessageApiView ( DjangoMessageDRFAuthMixin , ThreadMixin , RequireUserContextView , APIView ): \"\"\" Edits a message sent from a user in a given thread \"\"\" serializer_class = EDIT_MESSAGE_SERIALIZER def get_instance ( self , user , message_uuid ): \"\"\" Checks of the message exists \"\"\" try : return Message . objects . get ( sender = user , uuid = message_uuid ) except Message . DoesNotExist : return def get_serializer_context ( self ): context = super () . get_serializer_context () context . update ({ 'thread' : self . get_thead_by_id (), }) return context def put ( self , request , user_id , thread_id , * args , ** kwargs ): \"\"\" Edits a mensage in given thread. 1. Gets the user_id from the URL. 2. From the request.data gets the uuid of the message 3. Validates 4. Saves and returns \"\"\" user = self . get_user () if not user : raise NotFound () if ( not user . pk == request . user . pk ): raise PermissionDenied () # Get the instance of the message for a given user instance = self . get_instance ( user , request . data . get ( 'uuid' )) if not instance : raise NotFound () serializer = self . serializer_class ( instance , data = request . data , context = self . get_serializer_context ()) serializer . is_valid ( raise_exception = True ) instance = serializer . save () message = MessageSerializer ( instance , context = self . get_serializer_context ()) return Response ( message . data , status = status . HTTP_200_OK )","title":"EditMessageApiView"},{"location":"views/#general-tip","text":"The views follow a similar structure and design everywhere but they can also be overwritten in a normal Django way. Checkout the settings page to see how to override the variables.","title":"General Tip"},{"location":"overview/reference-guide/","text":"Reference Guide \u00b6 To make it a little bit clear how the project works, we provide a reference guide that can be updated at any time. URL\u2013View\u2013Template Matrix \u00b6 URL Name View django_messages_drf:inbox InboxListApiView django_messages_drf:thread ThreadListApiView django_messages_drf:thread-create ThreadCRUDApiView django_messages_drf:thread-send ThreadCRUDApiView django_messages_drf:thread-delete ThreadCRUDApiView django_messages_drf:message-edit EditMessageApiView","title":"Reference Guide"},{"location":"overview/reference-guide/#reference-guide","text":"To make it a little bit clear how the project works, we provide a reference guide that can be updated at any time.","title":"Reference Guide"},{"location":"overview/reference-guide/#urlviewtemplate-matrix","text":"URL Name View django_messages_drf:inbox InboxListApiView django_messages_drf:thread ThreadListApiView django_messages_drf:thread-create ThreadCRUDApiView django_messages_drf:thread-send ThreadCRUDApiView django_messages_drf:thread-delete ThreadCRUDApiView django_messages_drf:message-edit EditMessageApiView","title":"URL\u2013View\u2013Template Matrix"},{"location":"overview/signals/","text":"Signals \u00b6 We only provide one signal at the moment. message_sent = Signal ( providing_args = [ \"message\" , \"thread\" , \"reply\" ])","title":"Signals"},{"location":"overview/signals/#signals","text":"We only provide one signal at the moment. message_sent = Signal ( providing_args = [ \"message\" , \"thread\" , \"reply\" ])","title":"Signals"},{"location":"overview/url-names/","text":"URLs \u00b6 Names \u00b6 These URL names are available when using django_messages_drf urls.py : View Description django_messages_drf:inbox Inbox view. django_messages_drf:thread Lists the details of a tread of a User. Requires a UUID of a thread. django_messages_drf:thread-create Create new message to specific user. Requires a User PK (user to send). django_messages_drf:thread-send Replies to a thread. Requires thread UUID. django_messages_drf:thread-delete Delete message thread, requires thread UUID. django_messages_drf:message-edit Edits a message sent in a thread. django_messages_drf:inbox \u00b6 It doesn't require parameters django_messages_drf:thread \u00b6 Parameter Description Method uuid The UUID of a thread GET django_messages_drf:thread-create \u00b6 Creates a thread. Parameter Description Method user_id The user id GET message The content of the message POST subject The subject of the message POST django_messages_drf:thread-send \u00b6 Replies to the thread. Parameter Description Method uuid The UUID of a thread GET user_id The user id GET message The content of the message POST subject The subject of the message POST django_messages_drf:thread-delete \u00b6 Replies to the thread. Parameter Description Method uuid The UUID of a thread DELETE django_messages_drf:message-edit \u00b6 Edits a message sent by a given user. Parameter Description Method user_id The UUID of a thread GET thread_id The UUID of a thread GET uuid The UUID of the message to edit PUT content The content of the message PUT","title":"URLs"},{"location":"overview/url-names/#urls","text":"","title":"URLs"},{"location":"overview/url-names/#names","text":"These URL names are available when using django_messages_drf urls.py : View Description django_messages_drf:inbox Inbox view. django_messages_drf:thread Lists the details of a tread of a User. Requires a UUID of a thread. django_messages_drf:thread-create Create new message to specific user. Requires a User PK (user to send). django_messages_drf:thread-send Replies to a thread. Requires thread UUID. django_messages_drf:thread-delete Delete message thread, requires thread UUID. django_messages_drf:message-edit Edits a message sent in a thread.","title":"Names"},{"location":"overview/url-names/#django_messages_drfinbox","text":"It doesn't require parameters","title":"django_messages_drf:inbox"},{"location":"overview/url-names/#django_messages_drfthread","text":"Parameter Description Method uuid The UUID of a thread GET","title":"django_messages_drf:thread"},{"location":"overview/url-names/#django_messages_drfthread-create","text":"Creates a thread. Parameter Description Method user_id The user id GET message The content of the message POST subject The subject of the message POST","title":"django_messages_drf:thread-create"},{"location":"overview/url-names/#django_messages_drfthread-send","text":"Replies to the thread. Parameter Description Method uuid The UUID of a thread GET user_id The user id GET message The content of the message POST subject The subject of the message POST","title":"django_messages_drf:thread-send"},{"location":"overview/url-names/#django_messages_drfthread-delete","text":"Replies to the thread. Parameter Description Method uuid The UUID of a thread DELETE","title":"django_messages_drf:thread-delete"},{"location":"overview/url-names/#django_messages_drfmessage-edit","text":"Edits a message sent by a given user. Parameter Description Method user_id The UUID of a thread GET thread_id The UUID of a thread GET uuid The UUID of the message to edit PUT content The content of the message PUT","title":"django_messages_drf:message-edit"},{"location":"overview/views/","text":"Views \u00b6 The available views of the package, below. Name Description InboxListApiView Display all message threads. ThreadCRUDApiView Create a new message thread/Reply to Thread. Also Deletes a message. ThreadListApiView View specific message thread. EditMessageApiView Edits a specific message in a thread.","title":"Views"},{"location":"overview/views/#views","text":"The available views of the package, below. Name Description InboxListApiView Display all message threads. ThreadCRUDApiView Create a new message thread/Reply to Thread. Also Deletes a message. ThreadListApiView View specific message thread. EditMessageApiView Edits a specific message in a thread.","title":"Views"}]}